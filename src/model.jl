@with_kw mutable struct RobotNavigationMap
    map_name::Symbol = :map
    absolute_path::String = ""
    image # TODO: Figure out what this type is!
    image_width::Int = 0
    image_height::Int = 0

    function RobotNavigationMap(map_name::Symbol, filename::String)
        absolute_path = joinpath(@__DIR__, "..", "maps", filename)
        image = load(absolute_path)
        w, h = size(image, 2), size(image, 1)
        return new(map_name, absolute_path, image, w, h)
    end
end

@enum RobotNavigationColor begin
    BLACK
    WHITE
    RED
    GREEN
    BLUE
    MAGENTA
    YELLOW
    CYAN
end

const global OBSERVABLE_COLORS = (BLACK, WHITE, RED, GREEN, BLUE)
const global TASK_COLORS = (MAGENTA, YELLOW)
const global INITIAL_STATE_COLOR = CYAN
const global ALL_COLORS = (BLACK, WHITE, RED, GREEN, BLUE, MAGENTA, YELLOW, CYAN)

@with_kw mutable struct RobotNavigationPose
    x::Real = 0.0
    y::Real = 0.0
    Œ∏::Real = 0.0
end

@with_kw mutable struct RobotNavigationState
    pose::RobotNavigationPose = RobotNavigationPose()
    map_name::Symbol = :map
    task_color::RobotNavigationColor = MAGENTA
end

@with_kw mutable struct RobotNavigationAction
    desired_move::Bool = false
    desired_Œ∏::Real = 0.0
end

@with_kw mutable struct RobotNavigationScan
    œï::Real = 0.0       # Relative angle to robot's pose.
    depth::Real = 0.0   # Relative depth to robot's pose.
    color::RobotNavigationColor = WHITE
end

@with_kw mutable struct RobotNavigationObservation
    scans::Vector{RobotNavigationScan} = []
end

const RobotNavigationStates = Vector{RobotNavigationState}
const RobotNavigationActions = Vector{RobotNavigationAction}
const RobotNavigationObservations = Vector{RobotNavigationObservation}

@with_kw mutable struct RobotNavigationPOMDP <: POMDP{RobotNavigationState,
                                                      RobotNavigationAction,
                                                      RobotNavigationObservation}
    maps::Dict{Symbol, RobotNavigationMap} = Dict(
        :map => RobotNavigationMap(:map, "simple_test.png")
    )
    size_of_map::Dict{Symbol, NamedTuple{(:width, :height), Tuple{Int, Int}}} = Dict(
        :map => (width = 10, height = 10)
    )
    meters_per_pixel::Real = 1.0
    num_determinized_orientations::Int = 4 # NOTE: For deterministic only.
    max_tasks_per_map::Int = 1
    task_color_for_map::Dict{Symbol, Vector{RobotNavigationColor}} = Dict(
        :map => [MAGENTA]
    )
    robot_radius::Real = 0.25
    move_xy_max_speed::Real = 1.0
    move_Œ∏_max_speed::Real = float(œÄ) / 4.0
    move_xy_variance::Real = 0.1
    move_Œ∏_variance::Real = 0.1
    num_scans::Int = 3
    scan_field_of_view::Real = float(œÄ) / 2.0
    scan_range::Real = 5.0
    scan_depth_variance::Real = 0.25
    scan_color_observation_probability::Real = 0.9
end


@with_kw mutable struct RobotNavigationObservationDistribution
    ùí´::RobotNavigationPOMDP
    a::RobotNavigationAction
    s‚Ä≤::RobotNavigationState
end


function color_to_rgb(color::RobotNavigationColor)
    if color == BLACK
        return (r = 0.0, g = 0.0, b = 0.0)
    elseif color == WHITE
        return (r = 1.0, g = 1.0, b = 1.0)
    elseif color == GREEN
        return (r = 0.0, g = 1.0, b = 0.0)
    elseif color == RED
        return (r = 1.0, g = 0.0, b = 0.0)
    elseif color == BLUE
        return (r = 0.0, g = 0.0, b = 1.0)
    elseif color == MAGENTA
        return (r = 1.0, g = 0.0, b = 1.0)
    elseif color == YELLOW
        return (r = 1.0, g = 1.0, b = 0.0)
    elseif color == CYAN
        return (r = 0.0, g = 1.0, b = 1.0)
    else
        return (r = 0.3333, g = 0.333, b = 0.33)
    end
end


function iscolor(ùí´::RobotNavigationPOMDP, s::RobotNavigationState, color::RobotNavigationColor)
    image = ùí´.maps[s.map_name].image
    height = ùí´.maps[s.map_name].image_height
    width = ùí´.maps[s.map_name].image_width

    y = floor(Int, s.pose.y / ùí´.meters_per_pixel) + 1
    x = floor(Int, s.pose.x / ùí´.meters_per_pixel) + 1

    if y < 1 || y > height || x < 1 || x > width
        if color == BLACK
            return true
        else
            return false
        end
    end

    c = color_to_rgb(color)

    result = (
        c.r == convert(Float64, image[y, x].r)
        && c.g == convert(Float64, image[y, x].g)
        && c.b == convert(Float64, image[y, x].b)
    )

    return result
end


function POMDPs.states(ùí´::RobotNavigationPOMDP)
    ùíÆ::RobotNavigationStates = []
    for (m, map) in ùí´.maps
        for x in 1:floor(Int, ùí´.size_of_map[m].width * ùí´.meters_per_pixel)
            for y in 1:floor(Int, ùí´.size_of_map[m].height * ùí´.meters_per_pixel)
                for o in 1:ùí´.num_determinized_orientations
                    for t in ùí´.task_color_for_map[m]
                        s = RobotNavigationState(
                            pose = RobotNavigationPose(
                                x = x,
                                y = y,
                                Œ∏ = loop_angle(2.0 * œÄ * (o - 1) / ùí´.num_determinized_orientations)
                            ),
                            map_name = m,
                            task_color = t,
                        )
                        push!(ùíÆ, s)
                    end
                end
            end
        end
    end
    return ùíÆ
end


function POMDPs.stateindex(ùí´::RobotNavigationPOMDP, s::RobotNavigationState)
    # TODO: Make this more efficient later.

    ùíÆ = states(ùí´)
    for (i, s‚Ä≤) in ùíÆ
        if s‚Ä≤ == s
            return i
        end
    end

    return missing
end


function POMDPs.actions(ùí´::RobotNavigationPOMDP)
    ùíú::RobotNavigationActions = []
    for m in [false, true]
        for o in 1:ùí´.num_determinized_orientations
            a = RobotNavigationAction(
                desired_move = m,
                desired_Œ∏ = loop_angle(2.0 * œÄ * (o - 1) / ùí´.num_determinized_orientations),
            )
            push!(ùíú, a)
        end
    end
    return ùíú
end


function POMDPs.actionindex(ùí´::RobotNavigationPOMDP, a::RobotNavigationAction)
    # TODO: Make this more efficient later.

    ùíú = actions(ùí´)
    for (i, a‚Ä≤) in ùíú
        if a‚Ä≤ == a
            return i
        end
    end

    return missing
end


function POMDPs.observations(ùí´::RobotNavigationPOMDP)
    ùí™::RobotNavigationObservations = []
    depth_factors = [[
            0, ùí´.scan_range
        ] for i in 1:ùí´.num_scans
    ]

    color_factors = [[
            c for c in OBSERVABLE_COLORS
        ] for i in 1:ùí´.num_scans
    ]
    œïhalf = ùí´.scan_field_of_view / 2.0
    for d in permutations_with_replacement(depth_factors)
        for c in permutations_with_replacement(color_factors)
            depth_colors = []

            œïstep = ùí´.scan_field_of_view / (ùí´.num_scans - 1)
            for (i, œï) in enumerate(-œïhalf:œïstep:œïhalf)
                push!(
                    depth_colors,
                    RobotNavigationScan(
                        œï = loop_angle(œï),
                        depth = d[i],
                        color = c[i]
                    )
                )
            end
            o = RobotNavigationObservation(depth_colors)
            push!(ùí™, o)
        end
    end
    return ùí™
end


function POMDPs.transition(ùí´::RobotNavigationPOMDP, s::RobotNavigationState, a::RobotNavigationAction)
    s‚Ä≤‚Ä≤ = deepcopy(s)
    changed_Œ∏ = difference_of_angles(s.pose.Œ∏, a.desired_Œ∏) > 0.01

    if !a.desired_move && !changed_Œ∏
        return Deterministic(s‚Ä≤‚Ä≤)
    end

    # The xy noise is in meters and the Œ∏ noise is in radians.
    ùí©xy = Normal(0.0, ùí´.move_xy_variance)
    ùí©Œ∏ = Normal(
        clamp(
            turn_to_angle(s.pose.Œ∏, a.desired_Œ∏),
            -ùí´.move_Œ∏_max_speed,
            ùí´.move_Œ∏_max_speed
        ),
        ùí´.move_Œ∏_variance
    )

    move(rng, s‚Ä≤) = begin
        # Distance is in meters, but the for loop is over mainly pixels.
        # Pixels should be bigger jumps, and since we are only detecting
        # obstacles over them, we set the max iterations to be based
        # on a sub-pixel width, and allow for the step to be random.
        max_distance = ùí´.move_xy_max_speed
        sub_pixel_multiplier = 0.1
        max_iterations = max(
            ùí´.maps[s‚Ä≤.map_name].image_width,
            ùí´.maps[s‚Ä≤.map_name].image_height
        ) / sub_pixel_multiplier

        # NOTE: Always start the robot at its radius to prevent collisions.
        distance = ùí´.robot_radius
        for i in 1:max_iterations
            # We step forward in sub-pixel meters.
            step_size = sub_pixel_multiplier * ùí´.meters_per_pixel

            s‚Ä≤.pose.x += step_size * cos(s‚Ä≤.pose.Œ∏)
            s‚Ä≤.pose.y += step_size * sin(s‚Ä≤.pose.Œ∏)
            distance += step_size

            # If this is any observable color that is not white,
            # then we can collide with it too.
            if (any(iscolor(ùí´, s‚Ä≤, c)
                    for c in OBSERVABLE_COLORS
                    if c != WHITE)
                || distance >= max_distance
            )
                s‚Ä≤.pose.x -= step_size * cos(s‚Ä≤.pose.Œ∏)
                s‚Ä≤.pose.y -= step_size * sin(s‚Ä≤.pose.Œ∏)
                distance -= step_size
                break
            end
        end

        # Attempt to add random noise to this step length. However,
        # if it encounters a wall, undo this random step.
        random_step_size = rand(rng, ùí©xy)
        s‚Ä≤.pose.x += random_step_size * cos(s‚Ä≤.pose.Œ∏)
        s‚Ä≤.pose.y += random_step_size * sin(s‚Ä≤.pose.Œ∏)
        if iscolor(ùí´, s‚Ä≤, BLACK) 
            s‚Ä≤.pose.x -= random_step_size * cos(s‚Ä≤.pose.Œ∏)
            s‚Ä≤.pose.y -= random_step_size * sin(s‚Ä≤.pose.Œ∏)
        end

        return s‚Ä≤
    end
    turn(rng, s‚Ä≤) = begin
        s‚Ä≤.pose.Œ∏ = loop_angle(s‚Ä≤.pose.Œ∏ + rand(rng, ùí©Œ∏))
        return s‚Ä≤
    end
    turn_then_move(rng, s‚Ä≤) = begin
        s‚Ä≤.pose.Œ∏ = loop_angle(s‚Ä≤.pose.Œ∏ + rand(rng, ùí©Œ∏))
        return move(rng, s‚Ä≤)
    end

    deterministically_progress_task(s‚Ä≤) = begin
        for (i, c) in enumerate(ùí´.task_color_for_map[s‚Ä≤.map_name])
            if iscolor(ùí´, s‚Ä≤, c) && s‚Ä≤.task_color == c
                if i < length(ùí´.task_color_for_map[s‚Ä≤.map_name])
                    s‚Ä≤.task_color = ùí´.task_color_for_map[s‚Ä≤.map_name][i + 1]
                else
                    s‚Ä≤.task_color = ùí´.task_color_for_map[s‚Ä≤.map_name][1]
                end
                break
            end
        end
        return s‚Ä≤
    end
    deterministically_progress_task(s‚Ä≤‚Ä≤)

    if a.desired_move && !changed_Œ∏
        return ImplicitDistribution(rng -> move(rng, s‚Ä≤‚Ä≤))
    end

    if !a.desired_move && changed_Œ∏
        return ImplicitDistribution(rng -> turn(rng, s‚Ä≤‚Ä≤))
    end

    return ImplicitDistribution(rng -> turn_then_move(rng, s‚Ä≤‚Ä≤))
end


function deterministic_observation(ùí´::RobotNavigationPOMDP, a::RobotNavigationAction, s‚Ä≤::RobotNavigationState)
    s‚Ä≤‚Ä≤ = deepcopy(s‚Ä≤)

    deterministic_color(s‚Ä≤‚Ä≤‚Ä≤) = begin
        # These colors are the observable ones. Other colors
        # are not observable and are used for tasks.
        for c in OBSERVABLE_COLORS
            if iscolor(ùí´, s‚Ä≤‚Ä≤‚Ä≤, c)
                return c
            end
        end

        # If this s‚Ä≤‚Ä≤‚Ä≤ was in a non-observable color, then it
        # is treated as empty space (white).
        return WHITE
    end

    deterministic_depth_color(œï, s‚Ä≤‚Ä≤‚Ä≤) = begin
        # Depth is in meters, but the for loop is over mainly pixels.
        # Pixels should be bigger jumps, and since we are only detecting
        # obstacles over them, we set the max iterations to be based
        # on a sub-pixel width, and allow for the step to be random.
        # NOTE: We use scan range instead of max depth (transition's move).
        max_depth = ùí´.scan_range
        sub_pixel_multiplier = 0.1
        max_iterations = max(
            ùí´.maps[s‚Ä≤‚Ä≤‚Ä≤.map_name].image_width,
            ùí´.maps[s‚Ä≤‚Ä≤‚Ä≤.map_name].image_height
        ) / sub_pixel_multiplier

        depth = 0.0
        for i in 1:max_iterations
            # We step forward in sub-pixel meters.
            step_size = sub_pixel_multiplier * ùí´.meters_per_pixel

            s‚Ä≤‚Ä≤‚Ä≤.pose.x += step_size * cos(s‚Ä≤‚Ä≤‚Ä≤.pose.Œ∏ + œï)
            s‚Ä≤‚Ä≤‚Ä≤.pose.y += step_size * sin(s‚Ä≤‚Ä≤‚Ä≤.pose.Œ∏ + œï)
            depth += step_size

            # If this is any observable color that is not white,
            # then we can collide with it too.
            if (any(iscolor(ùí´, s‚Ä≤‚Ä≤‚Ä≤, c)
                    for c in OBSERVABLE_COLORS
                    if c != WHITE)
                || depth >= max_depth
            )
                break
            end
        end

        # NOTE: This s‚Ä≤‚Ä≤‚Ä≤ is updated to be in collision or max depth.
        return RobotNavigationScan(œï, depth, deterministic_color(s‚Ä≤‚Ä≤‚Ä≤))
    end

    scans = []

    œïhalf = ùí´.scan_field_of_view / 2.0
    if ùí´.num_scans > 1 
        œïstep = ùí´.scan_field_of_view / (ùí´.num_scans - 1)
        for œï in -œïhalf:œïstep:œïhalf
            s‚Ä≤‚Ä≤‚Ä≤ = deepcopy(s‚Ä≤‚Ä≤)
            push!(scans, deterministic_depth_color(loop_angle(œï), s‚Ä≤‚Ä≤‚Ä≤))
        end
    else
        s‚Ä≤‚Ä≤‚Ä≤ = deepcopy(s‚Ä≤‚Ä≤)
        push!(scans, deterministic_depth_color(0.0, s‚Ä≤‚Ä≤‚Ä≤))
    end

    return RobotNavigationObservation(scans)
end


function deterministic_observation(od::RobotNavigationObservationDistribution)
    return deterministic_observation(od.ùí´, od.a, od.s‚Ä≤)
end


function rand(rng::AbstractRNG, od::RobotNavigationObservationDistribution)
    o = deterministic_observation(od)

    for i in 1:length(o.scans)
        # The œï angle is already set and is fixed.
        #o.scans[i].œï = FIXED

        if rand(rng) >= od.ùí´.scan_color_observation_probability
            o.scans[i].color = rand(rng, OBSERVABLE_COLORS)
        end

        ùí©d = Normal(o.scans[i].depth, od.ùí´.scan_depth_variance)
        o.scans[i].depth = rand(rng, ùí©d)
    end

    return o
end


function POMDPs.pdf(od::RobotNavigationObservationDistribution, o::RobotNavigationObservation)
    o‚Ä≤ = deterministic_observation(od)

    p = 1.0

    for i in 1:length(o.scans)
        if o.scans[i].color == o‚Ä≤.scans[i].color
            p *= (
                od.ùí´.scan_color_observation_probability
                + (1.0 - od.ùí´.scan_color_observation_probability) * 1.0 / length(OBSERVABLE_COLORS)
            )
        else
            p *= 1.0 / length(OBSERVABLE_COLORS)
        end

        ùí©d = Normal(o‚Ä≤.scans[i].depth, od.ùí´.scan_depth_variance)
        p *= POMDPs.pdf(ùí©d, o.scans[i].depth)
    end

    return p
end


function POMDPs.observation(ùí´::RobotNavigationPOMDP, a::RobotNavigationAction, s‚Ä≤::RobotNavigationState)
    return RobotNavigationObservationDistribution(ùí´, a, s‚Ä≤)
end


function POMDPs.reward(ùí´::RobotNavigationPOMDP, s::RobotNavigationState, a::RobotNavigationAction)
    if iscolor(ùí´, s, s.task_color)
        return 0.0
    else
        return -1.0
    end
end


function POMDPs.initialstate(ùí´::RobotNavigationPOMDP)
    random_initial_pixel(rng, Œ∏, map_name, task_color) = begin
        image = ùí´.maps[map_name].image
        height = round(Int, size(image, 1))
        width = round(Int, size(image, 2))

        initial_pixels = []
        for py in 1:height
            for px in 1:width
                s = RobotNavigationState(
                    RobotNavigationPose(
                        px * ùí´.meters_per_pixel,
                        py * ùí´.meters_per_pixel,
                        Œ∏
                    ),
                    map_name,
                    task_color
                )
                if iscolor(ùí´, s, INITIAL_STATE_COLOR)
                    push!(initial_pixels, (y = py, x = px))
                end
            end
        end

        return rand(rng, initial_pixels)
    end

    b(rng) = begin
        map_name, map = rand(rng, ùí´.maps)
        task_color = rand(rng, ùí´.task_color_for_map[map_name])
        Œ∏ = rand(rng) * 2.0 * œÄ

        pixel = random_initial_pixel(rng, Œ∏, map_name, task_color)

        x = (pixel.x + rand(rng) * 0.5 + 0.25) * ùí´.meters_per_pixel
        y = (pixel.y + rand(rng) * 0.5 + 0.25) * ùí´.meters_per_pixel

        return RobotNavigationState(
            RobotNavigationPose(x, y, Œ∏),
            map_name,
            task_color
        )
    end

    return ImplicitDistribution(b)
end


POMDPs.discount(ùí´::RobotNavigationPOMDP) = 0.95
POMDPs.isterminal(ùí´::RobotNavigationPOMDP) = false

